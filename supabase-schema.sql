-- Supabase core schema (tables 1-8, enums, indexes, RLS). Generated by automation.
-- Run this in Supabase SQL editor or via supabase CLI migration.

-- 1. Extensions
create extension if not exists pgcrypto;

-- 2. Enums
create type message_role as enum ('user','ai','system');
create type quiz_question_type as enum ('mcq','mcma','tf','fitb');
create type export_format as enum ('pdf','docx','markdown');

-- 3. Tables
create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  avatar_url text,
  created_at timestamptz default now()
);

create table if not exists public.conversations (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  title text,
  archived boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists public.messages (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  user_id uuid references auth.users(id) on delete set null,
  role message_role not null,
  text text,
  is_quiz boolean default false,
  is_quiz_confirm boolean default false,
  meta jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

create table if not exists public.quiz_sessions (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  message_id uuid references public.messages(id) on delete set null,
  user_id uuid not null references auth.users(id) on delete cascade,
  subject text not null,
  question_count int not null check (question_count between 1 and 100),
  option_count int not null check (option_count between 2 and 8),
  difficulties text[] default array['medium'],
  types text[] not null,
  timer_seconds int,
  hints_enabled boolean default false,
  immediate_feedback boolean default false,
  score_correct int default 0,
  score_total int default 0,
  completed_at timestamptz,
  created_at timestamptz default now()
);

create table if not exists public.quiz_questions (
  id uuid primary key default gen_random_uuid(),
  quiz_session_id uuid not null references public.quiz_sessions(id) on delete cascade,
  order_index int not null,
  type quiz_question_type not null,
  question text not null,
  options text[],
  correct_index int,
  correct_indices int[],
  answer_text text,
  acceptable_answers text[],
  hint text,
  explanation text,
  created_at timestamptz default now(),
  constraint chk_q_indices check (
    (type in ('mcq','tf') and correct_index is not null)
    or (type = 'mcma' and correct_indices is not null)
    or (type = 'fitb' and answer_text is not null)
  )
);

create table if not exists public.quiz_answers (
  id uuid primary key default gen_random_uuid(),
  quiz_session_id uuid not null references public.quiz_sessions(id) on delete cascade,
  quiz_question_id uuid not null references public.quiz_questions(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  selected_indices int[],
  fill_text text,
  is_correct boolean,
  answered_at timestamptz default now(),
  unique (quiz_question_id, user_id)
);

create table if not exists public.uploaded_files (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  original_name text not null,
  storage_path text not null,
  mime_type text,
  size_bytes int,
  pages_count int,
  extracted_text text,
  created_at timestamptz default now()
);

create table if not exists public.exports (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  conversation_id uuid references public.conversations(id) on delete set null,
  format export_format not null,
  include_citations boolean default true,
  size_bytes int,
  duration_ms int,
  created_at timestamptz default now()
);

-- 4. Trigger to touch updated_at
create or replace function public.touch_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;

create or replace trigger trg_conversations_touch
before update on public.conversations
for each row execute function public.touch_updated_at();

-- 5. Indexes
create index if not exists idx_messages_conversation_created on public.messages (conversation_id, created_at);
create index if not exists idx_conversations_user on public.conversations (user_id, created_at desc);
create index if not exists idx_quiz_questions_session_order on public.quiz_questions (quiz_session_id, order_index);
create index if not exists idx_quiz_answers_session_user on public.quiz_answers (quiz_session_id, user_id);
create index if not exists idx_uploaded_files_user_created on public.uploaded_files (user_id, created_at);
create index if not exists idx_exports_user_created on public.exports (user_id, created_at desc);

-- 6. Enable RLS
alter table public.profiles enable row level security;
alter table public.conversations enable row level security;
alter table public.messages enable row level security;
alter table public.quiz_sessions enable row level security;
alter table public.quiz_questions enable row level security;
alter table public.quiz_answers enable row level security;
alter table public.uploaded_files enable row level security;
alter table public.exports enable row level security;

-- 7. Policies
create policy if not exists "profiles_select_own" on public.profiles for select using (user_id = auth.uid());
create policy if not exists "profiles_insert_self" on public.profiles for insert with check (user_id = auth.uid());
create policy if not exists "profiles_update_self" on public.profiles for update using (user_id = auth.uid()) with check (user_id = auth.uid());

create policy if not exists "conversations_crud_own" on public.conversations for all using (user_id = auth.uid()) with check (user_id = auth.uid());

create policy if not exists "messages_select_own_conv" on public.messages for select using (exists (select 1 from public.conversations c where c.id = messages.conversation_id and c.user_id = auth.uid()));
create policy if not exists "messages_insert_own_conv" on public.messages for insert with check (exists (select 1 from public.conversations c where c.id = messages.conversation_id and c.user_id = auth.uid()));

create policy if not exists "quiz_sessions_crud_own" on public.quiz_sessions for all using (user_id = auth.uid()) with check (user_id = auth.uid());
create policy if not exists "quiz_questions_select_parent_owner" on public.quiz_questions for select using (exists (select 1 from public.quiz_sessions qs where qs.id = quiz_questions.quiz_session_id and qs.user_id = auth.uid()));
create policy if not exists "quiz_answers_crud_own" on public.quiz_answers for all using (user_id = auth.uid()) with check (user_id = auth.uid());
create policy if not exists "uploaded_files_crud_own" on public.uploaded_files for all using (user_id = auth.uid()) with check (user_id = auth.uid());
create policy if not exists "exports_crud_own" on public.exports for all using (user_id = auth.uid()) with check (user_id = auth.uid());

-- 8. Optional helper trigger (title from first user message)
create or replace function public.set_conversation_title()
returns trigger language plpgsql as $$
begin
  if new.role = 'user' and (select title from public.conversations where id = new.conversation_id) is null then
    update public.conversations set title = left(new.text, 60) where id = new.conversation_id;
  end if;
  return new;
end $$;

create or replace trigger trg_messages_set_conv_title
after insert on public.messages
for each row execute function public.set_conversation_title();
